// ОБ'ЄКТ - НАБІР ВЛАСТИВОСТЕЙ, ЩО ПРЕДСТАВЛЕНІ ПАРОЮ ІМ'Я: ЗНАЧЕННЯ
// ТАКИХ ПАР МОЖЕ БУТИ БАГАТО, ВОНИ ВІДДІЛЯЮТЬСЯ МІЖ СОБОЮ КОМОЮ.
// СИНТАКСИС СТВОРЕННЯ - ОБ'ЄКТНИЙ ЛІТЕРАЛ

let person = {
  name: "Roman",
  age: 47,
  gender: "male",
};

// ПІСЛЯ СТВОРЕННЯ ЗМІННОЇ МОЖНА ЗВЕРТАТИСЯ ДО ОКРЕМИХ ВЛАСТИВОСТЕЙ ОБ'ЄКТА
//  ВЛАСТИВОСТІ ОБ'ЄКТУ ТАКОЖ МОЖНА НАЗИВАТИ ЇХНІМИ ПОЛЯМИ
// ДЛЯ ЗВЕРНЕННЯ ДО ПОЛІВ ВИКОРИСТОВУЄТЬСЯ ВИРАЗ ДОСТУПУ

// 1-й спосіб звернення: ОБ'ЄКТ.ІДЕНТИФІКАТОР

console.log(person.name);
console.log(person.age);

// 2-й спосіб звернення: ОБ'ЄКТ["ВИРАЗ"]

console.log(person["name"]);

// ПРИ 2-МУ СПОСОБІ ЗНАЧЕННЯ МОЖУТЬ ФОРМУВАТИСЯ ДИНАМІЧНО, ПРИ 1-МУ ПОВИННІ ОБОВ'ЯЗКОВО БУТИ ПРОПИСАНІ ЗАЗДАЛЕГІДЬ

// ТАКОЖ З ДОПОМОГОЮ ВИРАЗІВ ДОСТУПУ МОЖНА ЗМІНЮВАТИ ВЛАСТИВОСТІ ОБ'ЄКТУ:

person.age = 46;

//  АБО ДОДАВАТИ НОВІ ВЛАСТИВОСТІ:

person.userID = 190975;

console.log(person);

// ЗНАЧЕННЯМ ВЛАСТИВОСТІ ОБ'ЄКТУ МОЖЕ БУТИ ФУНКЦІЯ, ТОДІ ТАКУ ВЛАСТИВІСТЬ НАЗИВАЮТЬ МЕТОД:

let person1 = {
  name: "Roman",
  age: 47,
  gender: "male",
  sayHI: function () {
    return "Hello!";
  },
};

console.log(person1.sayHI());

// два інші способи створення об'єкту (крім об'єктного літералу) є створення за допомогою функції конструктора
// і оператору new:

let object2 = new Object();
object2.property = "value";

// - а також за допомогою методу .create, тобто створенню прототипу з класу Object, або наслідування.
// Якщо потрібно створити прототип без наслідуваних якостей, то в параметр записуємо null:

let object1 = Object.create(null);
console.log(object1);

// також при передачі властивостей з наслідуємого об'єкту, вони не наслідуються:

let object = Object.create({ x: 10, y: 20 });
console.log(object);

// про це свідчить false при виклику методу .hasOwnProperty

console.log(object.hasOwnProperty("x"));

// видалення властивостей об'єкту здійснюється за дапомогою оператора delete:

delete person.age;
console.log(person);

// при цьому видаляються тільки рідні, тобто не наслідні властивоті, видалення наслідних
// здійснюється в самому прототипі

// для перевірки наявності рідних або наслідних властивостей у об'єкта є бінарний оператор in,
// на відміну від методу .hasOwnProperty, який показує тільки рідні властивості:

console.log("age" in person);
console.log("name" in person);

// але при наданні неіснуючий властивості значення undefined, при перевірці цієї властивості оператором in вже буде true:

person.toy = undefined;
console.log(person.toy);
console.log("toy" in person);
