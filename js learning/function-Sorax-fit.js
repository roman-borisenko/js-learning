//  ФУНКЦІЯ - ІМЕНОВАНИЙ БЛОК КОДУ З ПАРАМЕТРАМИ ВХОДУ І ВИХОДУ

//ПРОСТЕ ОГОЛОШЕННЯ ФУНКЦІЇ (FUNCTION DECLARATION)
// (В ДАНОМУ ВИПАДКУ - КОНКАТЕНАЦІЯ ДВОХ РЯДКІВ)

function greet1(name) {
  return "Helo" + name;
}

// ВИКЛИК В КОНСОЛЬ КРІМ КОНКАТЕНІЦІЇ ЩЕ Й МЕТОДУ РЯДКА
// ТАКОЖ ПРИСВОЮВАННЯ ДОДАТКОВИХ АРГУМЕНТІВ ОБ'ЄКТУ ФУНКЦІЇ, ЯКИМ НЕ БУДЕ ПРИСВОЄНО ІМ'Я

console.log(greet1("Roman", 46, 19, 75).toUpperCase());

// ВСІМ НЕІНІЦІАЛІЗОВАНИМ АРГУМЕНТАМ БУДЕ ПРИСВОЄНО ЗНАЧЕННЯ "UNDEFINED"

console.log(greet1().toUpperCase());

// ______________________________________________

//   В ВИРАЗІ ВИЗНАЧЕННЯ ФУНКЦІЇ ЧЕРЕЗ ПРИСВОЮВАННЯ (FUNCTION EXPRESSION) МОЖНА ПРОПУСКАТИ ЇЇ ІМ'Я. ТОДІ ТАКА ФУНКЦІЯ НАЗ-СЯ АНОНІМНОЮ
// Такий спосіб оголошення функції краще відображає сутність того, що відбувається, а саме що функція - також об'єкт

let greet = function (name) {
  console.log(arguments.length);
  return "Helo, " + name;
};

console.log(greet("Roman", 46, 19, 75).toUpperCase());

// --------------------------------------------------------
//  ОСКІЛЬКИ ФУНКЦІЇ В ДЖС - ОБ'ЄКТИ, МИ МОЖЕМО ПЕРЕДАВАТИ ФУНКЦІЇ В ФУКЦІЇ В ЯКОСТІ АРГУМЕНТІВ, А ТАКОЖ ВЕРТАТИ ФУНКЦІЇЇ ІЗ ФУНКЦІЙ
//  ТОБТО ФУНЦІЯ МОДЕ БУТИ В ЯОСТІ КОЛБЕКА І ВИКОНУВАТИСЯ ПІСЛЯ ФУНКЦІЇЇ В ЯКУ ВОНА ПЕРЕДАЄТЬСЯ

let func1 = function (callback) {
  let name = "Roman";
  callback(name);
};

func1(function (n) {
  console.log("Hello, " + n);
});

// ---------------------------------------------------------
// ПРИКЛАД ФУНКЦІЇЇ - ВЕРТАЄМОГО ЗНАЧЕННЯ:

let func2 = function () {
  return function () {
    console.log("Hi");
  };
};

//  ТЕПЕР В МОМЕНТ ВИКЛИКУ ФУНКЦІЇ В ТОЧКУ ВИКЛИКУ ВЕРТАЄТЬСЯ АНОНІМНА ФУНКЦІЯ І ЯКЩО ЇЇ ВИКЛИКАТИ,
// ТО ПОБАЧИМО РЕЗУЛЬТАТИ ВИКЛИКУ В КОНСОЛІ

func2()();

// -----------------------------------------------------------------

//  ФУНКЦІЯ МОЖЕ БУТИ ВИКЛИКАНА В МОМЕНТ ВИЗНАЧЕННЯ, КОЛИ ЗАСТОСУВАТИ ВИРАЗ ВИЗНАЧЕННЯ

let greeting = (function (name) {
  return "hello, " + name;
})("Roman");

console.log(greeting);

// ТАКА ФУНКЦІЯ, ЯКА ВИКЛИКАЄТЬСЯ ВІДРАЗУ ПІЛЯ ВИЗНАЧЕННЯ НАЗИВАЄТЬСЯ "АНОНІМНОЮ САМОВИКЛИКАЮЧОЮ ФУНКЦІЄЮ "
// ЗВІСНО, МОЖНА ДАТИ ІМ'Я ТАКІЙ ФУНКЦІЇ. ЦЕ БУДЕ ДОРЕЧНО У ВИПАДКУ, КОЛИ ФУНКЦІЯ ВИКЛИКАЄ САМУ СЕБЕ, ТОБТО
// ЯВЛЯЄТЬСЯ РЕКУРСІЄЮ (НАПР. ПРИ ОБЧИСЛЕННІ ЧИСЕЛ ФІБОНАЧЧІ (КОЖНЕ НАСТУПНЕ ЧИСЛО Є СУМОЮ ДВОХ ПОПЕРЕДНІХ),
// АБО ВИЧИСЛЕННІ ВИЗНАЧНИКА МАТРИЦІ, ЯКИЙ ДОРІВНЮЄ
// СУМІ ПОХІДНИХ ЄЛЕМЕНТІВ РЯДКА (СТОВПЧИКА) НА ВІДПОВІДНЕ АЛГЕБРАІЧНЕ ДОПОВНЕННЯ)

// ----------------------------------------------------------------------

//  ПРИ ВИКОНАННІ ФУНКЦІЇ В ДЖС ВИКОРИСТОВУЄТЬСЯ ТА ОБЛАСТЬ ВИДИМОСТІ, ЯКА ІСНУВАЛА ПРИ ОБ'ЯВІ ЦІЄЇ ФУНКЦІЇ

let func = function () {
  let i = 10;
  return function () {
    return i;
  };
};

let anoutherFunc = function () {
  let i = 20;
  console.log(func()());
};

anoutherFunc();

// i = 10

//  З КОЖНОЮ ФУНКЦІЄЮ ПОВ'ЯЗАНИЙ ЛАНЦЮЖОК ОБЛАСТЕЙ ВИДИМОСТІ ЗМІННИХ.
// ФУНКЦІЯ З ТАКИМ ЛАНЦЮЖКОМ НАЗІВАЄТЬСЯ ЗАМИКАННЯМ

// -------------------------------------------------------

// ПРИКЛАД ФУНКЦІЇ ЗАМИКАННЯ (ЛІЧИЛЬНИК):

let counter1 = (function () {
  let count = 0;
  return function (num) {
    count = num !== undefined ? num : count;
    return count++;
  };
})();

console.log(counter1());
console.log(counter1());
console.log(counter1(0));
console.log(counter1());
console.log(counter1());
console.log(counter1());

// ТУТ ДІЄ ПРИНЦИП ІНКАПСУЛЯЦІЇ (ЗБЕРЕЖЕННІ) ПОПЕРЕДНІХ ДАНИХ, КОЛИ ПРИ КОЖНОМУ ВИКЛИКУ ВИВОДИТСЯ ІНШЕ ЗНАЧЕННЯ

// ------------------------------------------------------------------

// інший спосіб лічильника (через додавання змінної COUNT як властивості об'єкта COUNTER):

let counter = function (num) {
  counter.count = num !== undefined ? num : counter.count;
  return counter.count++;
};

counter.count = 0;

console.log(counter());
console.log(counter());
console.log(counter(0));
console.log(counter());
console.log(counter());
console.log(counter());

// --------------------------------------------------------------------
